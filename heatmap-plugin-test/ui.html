<!DOCTYPE html>
<html>
<head>
  <style>
    html, body {
      margin: 0;
      padding: 0;
    }
    
    body {
      width: 375px;
      height: 560px;
      font-family: sans-serif;
      background: #fff;
      overflow: hidden;
    }
    
    h2 {
      font-family: "SF Pro", -apple-system, sans-serif;
      font-weight: 600;
      font-size: 16px;
      margin: 0 0 16px 0;
    }
    
    .divider {
      height: 1px;
      background-color: #e0e0e0;
      margin: 0 0 16px 0;
      width: 100%;
    }
    
    #container {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
    }
    
    .top-section {
      padding: 16px;
      border-bottom: 1px solid #e0e0e0;
      flex-shrink: 0;
    }
    
    .chat-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .chat-header {
      padding: 12px 16px;
      background: #f8f9fa;
      border-bottom: 1px solid #e0e0e0;
      flex-shrink: 0;
    }
    
    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 12px 16px;
      background: #f8f9fa;
    }
    
    .message {
      margin-bottom: 12px;
      display: flex;
      align-items: flex-start;
      gap: 8px;
    }
    
    .message.user {
      justify-content: flex-end;
    }
    
    .message-avatar {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: 600;
      flex-shrink: 0;
    }
    
    .message.user .message-avatar {
      background: #1976d2;
      color: white;
    }
    
    .message.assistant .message-avatar {
      background: #f0f0f0;
      color: #666;
    }
    
    .message-content {
      max-width: 70%;
      padding: 8px 12px;
      border-radius: 12px;
      font-size: 13px;
      line-height: 1.4;
      word-wrap: break-word;
    }
    
    .message.user .message-content {
      background: #1976d2;
      color: white;
      border-bottom-right-radius: 4px;
    }
    
    .message.assistant .message-content {
      background: white;
      color: #333;
      border: 1px solid #e0e0e0;
      border-bottom-left-radius: 4px;
    }
    
    .chat-input-container {
      padding: 12px 16px;
      border-top: 1px solid #e0e0e0;
      background: white;
      flex-shrink: 0;
    }
    
    .chat-input-form {
      display: flex;
      gap: 8px;
      align-items: flex-end;
    }
    
    .chat-input {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid #e0e0e0;
      border-radius: 16px;
      font-size: 13px;
      outline: none;
      resize: none;
      min-height: 32px;
      max-height: 80px;
      font-family: inherit;
    }
    
    .chat-input:focus {
      border-color: #1976d2;
    }
    
    .send-button {
      background: #1976d2;
      color: white;
      border: none;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      transition: background-color 0.2s;
    }
    
    .send-button:hover {
      background: #1565c0;
    }
    
    .send-button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    .send-button svg {
      width: 14px;
      height: 14px;
    }
    
    .option-buttons {
      display: flex;
      gap: 4px;
      margin: 8px 0;
      padding: 8px;
      background: white;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
      overflow-x: auto;
      overflow-y: hidden;
      white-space: nowrap;
      scrollbar-width: thin;
      scrollbar-color: #c0c0c0 #f8f9fa;
      max-width: 100%;
      box-sizing: border-box;
      min-height: 40px;
      align-items: center;
    }

    .option-buttons::-webkit-scrollbar {
      height: 6px;
    }

    .option-buttons::-webkit-scrollbar-track {
      background: #f8f9fa;
      border-radius: 3px;
    }

    .option-buttons::-webkit-scrollbar-thumb {
      background: #c0c0c0;
      border-radius: 3px;
    }

    .option-buttons::-webkit-scrollbar-thumb:hover {
      background: #a0a0a0;
    }

    .option-buttons::after {
      content: '';
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 20px;
      background: linear-gradient(to right, transparent, white);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .option-buttons.has-more::after {
      opacity: 1;
    }
    
    .option-button {
      background: #f0f0f0;
      color: #333;
      border: 1px solid #ccc;
      padding: 6px 10px;
      border-radius: 12px;
      cursor: pointer;
      font-size: 11px;
      transition: all 0.2s;
      white-space: nowrap;
      flex-shrink: 0;
      min-width: fit-content;
    }
    
    .option-button:hover {
      background: #e0e0e0;
    }
    
    .option-button:active {
      transform: translateY(1px);
    }
    
    .option-button.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .skip-button {
      background: #ff6b6b !important;
      color: white !important;
      border-color: #ff5252 !important;
    }
    
    .skip-button:hover {
      background: #ff5252 !important;
    }
    
    .typing-indicator {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 8px 12px;
      background: white;
      border-radius: 12px;
      border: 1px solid #e0e0e0;
      max-width: 70%;
      margin-bottom: 12px;
    }
    
    .typing-dot {
      width: 6px;
      height: 6px;
      background: #999;
      border-radius: 50%;
      animation: typing 1.4s infinite ease-in-out;
    }
    
    .typing-dot:nth-child(1) { animation-delay: -0.32s; }
    .typing-dot:nth-child(2) { animation-delay: -0.16s; }
    
    @keyframes typing {
      0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
      40% { transform: scale(1); opacity: 1; }
    }
    
    .loading {
      display: none;
      margin-top: 10px;
      text-align: center;
    }
    
    .loading svg {
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin { 100% { transform: rotate(360deg); } }
    
    .options-container {
      display: flex;
      flex-wrap: wrap;
      gap: 2px;
      margin-bottom: 16px;
    }
    
    .option-box {
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid #ccc;
      padding: 6px 8px;
      cursor: pointer;
      transition: all 0.2s;
      margin-right: 4px;
      margin-bottom: 4px;
      user-select: none;
    }
    
    .option-box[data-value="title"] {
      width: 40px;
    }
    
    .option-box[data-value="location"] {
      width: 50px;
    }
    
    .option-box[data-value="time"] {
      width: 40px;
    }
    
    .option-box[data-value="host"] {
      width: 40px;
    }
    
    .option-box[data-value="purpose"] {
      width: 50px;
    }
    
    .option-box[data-value="other/descriptions"] {
      width: 110px;
    }
    
    .option-box:hover {
      background-color: #f5f5f5;
    }
    
    .option-box.selected {
      background-color: #1976d2;
      color: white;
      border-color: #1976d2;
    }
    
    .option-box span {
      font-size: 12px;
      font-weight: 400;
      white-space: nowrap;
    }
    
    #send {
      margin-left: auto;
      margin-top: 4px;
      padding: 8px;
      background-color: #1976d2;
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
      transition: background-color 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
    }
    
    #send:hover {
      background-color: #1565c0;
    }
    
    #send:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    
    .controls {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }
    
    .control-button {
      background: #f0f0f0;
      color: #666;
      border: none;
      padding: 6px 12px;
      border-radius: 12px;
      cursor: pointer;
      font-size: 11px;
      transition: background 0.2s;
    }
    
    .control-button:hover {
      background: #e0e0e0;
    }
    
    .skip-button {
      background: #ff6b6b !important;
      color: white !important;
    }
    
    .skip-button:hover {
      background: #ff5252 !important;
    }

    .latest-prompt-display {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 12px 16px;
      border-radius: 8px;
      margin: 8px 16px;
      position: sticky;
      top: 0;
      z-index: 10;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .latest-prompt-text {
      font-size: 13px;
      line-height: 1.4;
      font-weight: 500;
      outline: none;
      min-height: 1.4em;
      padding: 2px 0;
    }

    .latest-prompt-text:focus {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      padding: 2px 4px;
    }

    .latest-prompt-text .diff-added {
      background: rgba(255, 255, 255, 0.2);
      color: #ffffff;
      padding: 2px 4px;
      border-radius: 3px;
      font-weight: 600;
    }

    .latest-prompt-text .diff-unchanged {
      color: #ffffff;
    }
  </style>
</head>
<body>
<div id="container">
  <!-- Top Section: Layout Generation -->
  <div class="top-section">
    <h2>Generate layout guides</h2>
    <div class="options-container">
      <div class="option-box" data-value="title">
        <span>Title</span>
      </div>
      <div class="option-box" data-value="location">
        <span>Location</span>
      </div>
      <div class="option-box" data-value="time">
        <span>Time</span>
      </div>
      <div class="option-box" data-value="host">
        <span>Host</span>
      </div>
      <div class="option-box" data-value="purpose">
        <span>Purpose</span>
      </div>
      <div class="option-box" data-value="other/descriptions">
        <span>Other / Descriptions</span>
      </div>
      <button type="button" id="send">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
          <path d="M8 2L14 8L12.6 9.4L9 5.8V16H7V5.8L3.4 9.4L2 8L8 2Z"/>
        </svg>
      </button>
    </div>
    <div class="divider"></div>
  </div>

  <!-- Chat Section -->
  <div class="chat-section">
    <div class="chat-header">
      <h2>Prompt Refinement</h2>
    </div>
    
    <!-- Editable Prompt Display -->
    <div class="latest-prompt-display" id="latestPromptDisplay" style="display: none;">
      <div class="latest-prompt-text" id="latestPromptText" contenteditable="true"></div>
    </div>
    
    <div class="chat-messages" id="chatMessages">
      <div class="message assistant">
        <div class="message-avatar">AI</div>
        <div class="message-content">
          Hello! I'm your prompt refinement assistant. Type your prompt below and I'll help you refine it for better layout generation.
        </div>
      </div>
    </div>
    
    <div class="loading" id="loading">
      <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
        <circle cx="16" cy="16" r="14" stroke="#888" stroke-width="4" fill="none" opacity="0.2"/>
        <circle cx="16" cy="16" r="14" stroke="#1976d2" stroke-width="4" fill="none" stroke-dasharray="40 60"/>
      </svg>
      <div>AI is thinking...</div>
    </div>
    
    <div class="chat-input-container">
      <form class="chat-input-form" id="chatForm">
        <textarea 
          class="chat-input" 
          id="chatInput" 
          placeholder="Type your prompt here..."
          rows="1"
        ></textarea>
        <button type="submit" class="send-button" id="chatSendButton">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
          </svg>
        </button>
      </form>
      
      <div class="controls">
        <button class="control-button" onclick="resetChat()">Reset Chat</button>
        <button class="control-button skip-button" onclick="skipQuestion()" id="skipButton" style="display: none;">Skip Question</button>
      </div>
    </div>
  </div>
</div>

<script>
const API_BASE = 'http://localhost:5000';
let conversationHistory = [];
let currentPrompt = '';
let isWaitingForResponse = false;
let isInitialPrompt = true;
let isUserEdit = false;
let askedQuestions = new Set();

const chatMessages = document.getElementById('chatMessages');
const chatInput = document.getElementById('chatInput');
const chatSendButton = document.getElementById('chatSendButton');
const chatForm = document.getElementById('chatForm');
const loading = document.getElementById('loading');
const skipButton = document.getElementById('skipButton');
const latestPromptDisplay = document.getElementById('latestPromptDisplay');
const latestPromptText = document.getElementById('latestPromptText');
const sendBtn = document.getElementById('send');

// Auto-resize textarea
chatInput.addEventListener('input', function() {
  this.style.height = 'auto';
  this.style.height = Math.min(this.scrollHeight, 80) + 'px';
});

function generateDiff(oldText, newText) {
  // Concept-focused diff that only shows additions
  const words1 = oldText.split(' ');
  const words2 = newText.split(' ');
  
  let result = '';
  let i = 0, j = 0;
  
  while (i < words1.length || j < words2.length) {
    if (i < words1.length && j < words2.length && words1[i] === words2[j]) {
      // Same word
      result += `<span class="diff-unchanged">${words1[i]}</span> `;
      i++;
      j++;
    } else {
      // Handle additions only
      let addedWords = [];
      
      // Collect all consecutive added words
      while (j < words2.length && (i >= words1.length || words1[i] !== words2[j])) {
        addedWords.push(words2[j]);
        j++;
      }
      
      // Skip removed words (don't display them)
      while (i < words1.length && (j >= words2.length || words1[i] !== words2[j])) {
        i++;
      }
      
      // Add added words as a group
      if (addedWords.length > 0) {
        result += `<span class="diff-added">${addedWords.join(' ')}</span> `;
      }
    }
  }
  
  return result.trim();
}

function updateLatestPromptDisplay(prompt) {
  if (prompt) {
    // Remove quotation marks from the prompt
    const cleanPrompt = prompt.replace(/^["']|["']$/g, '');
    
    // Only show diff if this is an AI-generated update, not user edits
    if (currentPrompt && cleanPrompt !== currentPrompt && !isUserEdit) {
      // Show diff highlighting when not editing
      const diffHtml = generateDiff(currentPrompt, cleanPrompt);
      latestPromptText.innerHTML = diffHtml;
    } else {
      // Show plain text when editing or no changes
      latestPromptText.textContent = cleanPrompt;
    }
    latestPromptDisplay.style.display = 'block';
  } else {
    latestPromptDisplay.style.display = 'none';
  }
}

// Handle editing the current prompt
latestPromptText.addEventListener('focus', function() {
  // Show plain text when editing
  this.textContent = currentPrompt || '';
  isUserEdit = true;
});

latestPromptText.addEventListener('blur', function() {
      const editedPrompt = this.textContent.trim();
    if (editedPrompt && editedPrompt !== currentPrompt) {
      // Update the current prompt
      currentPrompt = editedPrompt.replace(/^["']|["']$/g, '');
    isUserEdit = false; // Reset flag after user edit
    
    // If AI was waiting for a response to a question, replace the last AI message
    if (isWaitingForResponse) {
      // Add a user message indicating they edited the prompt
      addMessage("(Edited prompt)", 'user');
      
      // Remove the last AI message (the question)
      const lastAIMessage = chatMessages.querySelector('.message.assistant:last-child');
      if (lastAIMessage) {
        lastAIMessage.remove();
      }
      // Clear any option buttons
      clearOptionButtons();
    }
    
    // Send the edited prompt to continue refinement
    setTimeout(() => {
      continueRefinement(editedPrompt);
    }, 500);
  } else {
    isUserEdit = false; // Reset flag
    // Restore diff highlighting if no changes were made
    updateLatestPromptDisplay(currentPrompt);
  }
});

// Handle Enter key to finish editing
latestPromptText.addEventListener('keydown', function(e) {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    this.blur(); // This will trigger the blur event
  }
});

function addMessage(content, role) {
  const messageDiv = document.createElement('div');
  messageDiv.className = `message ${role}`;
  
  const avatar = document.createElement('div');
  avatar.className = 'message-avatar';
  avatar.textContent = role === 'user' ? 'You' : 'AI';
  
  const contentDiv = document.createElement('div');
  contentDiv.className = 'message-content';
  
  // Clean the content for display (remove options from AI questions)
  let displayContent = content;
  if (role === 'assistant' && isQuestionWithOptions(content)) {
    displayContent = cleanQuestionContent(content);
  }
  
  contentDiv.textContent = displayContent;
  
  messageDiv.appendChild(avatar);
  messageDiv.appendChild(contentDiv);
  
  chatMessages.appendChild(messageDiv);
  chatMessages.scrollTop = chatMessages.scrollHeight;
  
  // If this is an AI message with options, show option buttons
  if (role === 'assistant' && isQuestionWithOptions(content)) {
    console.log('Question with options detected:', content);
    const options = extractOptionsFromResponse(content);
    console.log('Extracted options:', options, 'from content:', content);
    if (options.length > 0) {
      showOptionButtons(options);
    } else {
      console.log('No options extracted from question with options');
      console.log('Question end pattern match:', content.match(/\?([^.!?]+)/));
    }
    trackQuestion(content);
  } else if (role === 'assistant') {
    console.log('Not a question with options:', content);
  }
}

function cleanQuestionContent(content) {
  const optionsPattern = /\s*[Oo]ptions?:\s*[^.!?]+[.!?]?/g;
  return content.replace(optionsPattern, '').trim();
}

function extractQuestionKey(content) {
  let question = content.toLowerCase();
  question = question.replace(/^(what|which|how|when|where|why|do you|would you|could you|can you)\s+/i, '');
  question = question.replace(/\?/g, '');
  question = question.replace(/\s+/g, ' ').trim();
  const commonWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by'];
  question = question.split(' ').filter(word => !commonWords.includes(word)).join(' ');
  return question;
}

function isQuestionAlreadyAsked(content) {
  const questionKey = extractQuestionKey(content);
  return askedQuestions.has(questionKey);
}

function trackQuestion(content) {
  const questionKey = extractQuestionKey(content);
  askedQuestions.add(questionKey);
}

function checkForRepetitiveQuestion(content) {
  if (isQuestionWithOptions(content)) {
    const cleanedQuestion = cleanQuestionContent(content);
    if (isQuestionAlreadyAsked(cleanedQuestion)) {
      return true;
    }
  }
  return false;
}

function showLoading() {
  loading.style.display = 'block';
  chatSendButton.disabled = true;
  chatInput.disabled = true;
  skipButton.style.display = 'none';
}

function hideLoading() {
  loading.style.display = 'none';
  chatSendButton.disabled = false;
  chatInput.disabled = false;
  if (isWaitingForResponse) {
    skipButton.style.display = 'inline-block';
  }
}

function isQuestionWithOptions(aiResponse) {
  const response = aiResponse.toLowerCase();
  
  // Check if it's a question (contains ?)
  if (!response.includes('?')) return false;
  
  // Check if it's not an updated prompt
  if (response.includes('updated prompt:')) return false;
  
  // Check for various option indicators
  const optionIndicators = [
    'options:', 'choices:', 'versions:', 'select', 'choose', 'pick',
    'v6', 'v5', 'v4', 'v7', 'v8', 'mj', 'midjourney', 'niji', '--v'
  ];
  
  // Check if any option indicators are present
  const hasOptionIndicators = optionIndicators.some(indicator => response.includes(indicator));
  
  // Also check if there are comma-separated items after the question mark
  const questionEndPattern = /\?([^.!?]+)/;
  const questionEndMatch = response.match(questionEndPattern);
  const hasCommaSeparatedItems = questionEndMatch && questionEndMatch[1].includes(',');
  
  return hasOptionIndicators || hasCommaSeparatedItems;
}

function extractOptionsFromResponse(aiResponse) {
  const options = [];
  
  // First, try to extract options that are directly after a question mark
  const questionEndPattern = /\?([^.!?]+)/;
  const questionEndMatch = aiResponse.match(questionEndPattern);
  
  if (questionEndMatch && questionEndMatch[1]) {
    let optionText = questionEndMatch[1].trim();
    console.log('Raw option text after question mark:', optionText);
    
    // Clean up common prefixes/suffixes
    optionText = optionText.replace(/^[,\s]+/, '').replace(/[,\s]+$/, '');
    console.log('Cleaned option text:', optionText);
    
    if (optionText) {
      // Split by comma and clean each option
      const optionList = optionText.split(',').map(opt => opt.trim()).filter(opt => opt.length > 0);
      console.log('Option list before filtering:', optionList);
      
      // Filter and validate options
      const filteredOptions = optionList.filter(opt => {
        const cleanOpt = opt.toLowerCase();
        
        // Special handling for single digits that might be version numbers
        if (/^\d+$/.test(opt) && opt.length <= 2) {
          // Convert single digits to version format
          const versionNum = parseInt(opt);
          if (versionNum >= 4 && versionNum <= 8) {
            console.log(`Converting single digit "${opt}" to "--v ${opt}.0"`);
            return false; // We'll handle this conversion separately
          }
        }
        
        const isValid = opt.length >= 2 && 
               opt.length <= 30 && 
               !cleanOpt.includes('options') &&
               !cleanOpt.includes('choices') &&
               !cleanOpt.includes('version') &&
               !cleanOpt.includes('select') &&
               !cleanOpt.includes('choose') &&
               !cleanOpt.includes('thinking') &&
               !cleanOpt.includes('for the') &&
               /^[a-zA-Z0-9\s\-\.\-\-]+$/.test(opt); // Allow -- for Midjourney parameters
        
        if (!isValid) {
          console.log(`Filtered out option "${opt}" - length: ${opt.length}, cleanOpt: "${cleanOpt}"`);
        }
        return isValid;
      });
      
      // Handle single digit version numbers
      const processedOptions = [];
      for (let i = 0; i < optionList.length; i++) {
        const opt = optionList[i];
        if (/^\d+$/.test(opt) && opt.length <= 2) {
          const versionNum = parseInt(opt);
          if (versionNum >= 4 && versionNum <= 8) {
            processedOptions.push(`--v ${opt}.0`);
            console.log(`Added processed version: --v ${opt}.0`);
          }
        } else if (filteredOptions.includes(opt)) {
          processedOptions.push(opt);
        }
      }
      
      console.log('Processed options:', processedOptions);
      console.log('Original option list:', optionList);
      console.log('Filtered options:', filteredOptions);
      
      if (processedOptions.length >= 2 && processedOptions.length <= 8) {
        console.log(`Using processed options: ${processedOptions.length} options`);
        options.push(...processedOptions);
        return options;
      } else {
        console.log(`Not enough processed options: ${processedOptions.length} (need 2-8)`);
      }
      
      if (filteredOptions.length >= 2 && filteredOptions.length <= 8) {
        console.log(`Using filtered options: ${filteredOptions.length} options`);
        options.push(...filteredOptions);
        return options;
      } else {
        console.log(`Not enough filtered options: ${filteredOptions.length} (need 2-8)`);
      }
    }
  }
  
  // Try multiple patterns to extract options
  const patterns = [
    /options?:\s*([^.!?]+)/i,
    /choices?:\s*([^.!?]+)/i,
    /versions?:\s*([^.!?]+)/i,
    /([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*(?:\s*,\s*[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)*)/g
  ];
  
  for (const pattern of patterns) {
    const matches = aiResponse.match(pattern);
    if (matches) {
      let optionText = matches[1] || matches[0];
      
      // Clean up the option text
      optionText = optionText.replace(/^[^a-zA-Z]*/, '').replace(/[^a-zA-Z]*$/, '');
      
      if (optionText) {
        const optionList = optionText.split(/[,\s]+/).map(opt => opt.trim()).filter(opt => opt.length > 0);
        
        // Filter and validate options
        const filteredOptions = optionList.filter(opt => {
          const cleanOpt = opt.toLowerCase();
          return opt.length >= 2 && 
                 opt.length <= 30 && 
                 !cleanOpt.includes('options') &&
                 !cleanOpt.includes('choices') &&
                 !cleanOpt.includes('version') &&
                 !cleanOpt.includes('select') &&
                 !cleanOpt.includes('choose') &&
                 /^[a-zA-Z0-9\s\-\.]+$/.test(opt); // Only allow letters, numbers, spaces, hyphens, and dots
        });
        
        if (filteredOptions.length >= 2 && filteredOptions.length <= 8) {
          options.push(...filteredOptions);
          break; // Use the first successful pattern
        }
      }
    }
  }
  
  // If no options found with patterns, try to extract from common Midjourney version formats
  if (options.length === 0) {
    const midjourneyPatterns = [
      /(--v\s*\d+(?:\.\d+)?)/gi,
      /(v\d+(?:\.\d+)?)/gi,
      /(MJ\s*\d+)/gi,
      /(Midjourney\s*\d+)/gi,
      /(Niji\s*\d+)/gi
    ];
    
    for (const pattern of midjourneyPatterns) {
      const matches = aiResponse.match(pattern);
      if (matches && matches.length >= 2) {
        const uniqueMatches = [...new Set(matches.map(m => m.trim()))];
        if (uniqueMatches.length >= 2 && uniqueMatches.length <= 6) {
          options.push(...uniqueMatches);
          break;
        }
      }
    }
  }
  
  // Final fallback: if we have some options but they seem incomplete, try to infer missing versions
  // Only infer if we have very few options (1-2) and it's clearly a version question
  if (options.length > 0 && options.length <= 2 && aiResponse.toLowerCase().includes('version')) {
    console.log('Attempting to infer missing version options...');
    console.log('Current options before inference:', options);
    
    // Look for any version numbers mentioned in the response
    const versionMatches = aiResponse.match(/\d+/g);
    if (versionMatches) {
      const versionNumbers = [...new Set(versionMatches.map(v => parseInt(v)))].filter(v => v >= 4 && v <= 8);
      console.log('Found version numbers in response:', versionNumbers);
      
      // Add missing versions that are commonly used, but be more conservative
      const commonVersions = [5, 6, 7]; // Focus on most common versions
      const missingVersions = commonVersions.filter(v => !versionNumbers.includes(v));
      console.log('Missing versions to add:', missingVersions);
      
      // Only add 1-2 missing versions to reach a reasonable total
      const targetCount = Math.min(4, options.length + 2); // Aim for 3-4 total options
      const versionsToAdd = missingVersions.slice(0, targetCount - options.length);
      
      for (const version of versionsToAdd) {
        const versionOption = `--v ${version}.0`;
        if (!options.includes(versionOption)) {
          options.push(versionOption);
          console.log(`Added inferred version: ${versionOption}`);
        }
      }
      
      // Sort options by version number
      options.sort((a, b) => {
        const aMatch = a.match(/(\d+)/);
        const bMatch = b.match(/(\d+)/);
        if (aMatch && bMatch) {
          return parseInt(aMatch[1]) - parseInt(bMatch[1]);
        }
        return 0;
      });
      
      console.log('Final options after inference:', options);
    }
  }
  
  console.log('Final extracted options:', options);
  console.log('Total number of options:', options.length);
  return options;
}

function showOptionButtons(options) {
  clearOptionButtons();
  
  console.log('Creating option buttons for:', options);
  
  const buttonContainer = document.createElement('div');
  buttonContainer.className = 'option-buttons';
  
  options.forEach((option, index) => {
    const button = document.createElement('button');
    button.className = 'option-button';
    button.textContent = option;
    button.onclick = () => {
      const allButtons = buttonContainer.querySelectorAll('.option-button');
      allButtons.forEach(btn => btn.classList.add('disabled'));
      sendUserResponse(option);
    };
    buttonContainer.appendChild(button);
    console.log(`Created button ${index + 1}:`, option);
  });
  
  const chatInputContainer = document.querySelector('.chat-input-container');
  chatInputContainer.parentNode.insertBefore(buttonContainer, chatInputContainer);
  
  // Debug: Check if buttons are actually in the DOM
  const actualButtons = buttonContainer.querySelectorAll('.option-button');
  console.log(`Total buttons created: ${actualButtons.length}`);
  console.log('Button container width:', buttonContainer.offsetWidth);
  console.log('Button container scroll width:', buttonContainer.scrollWidth);
  
  // Add visual indicator if there are more options to scroll
  if (buttonContainer.scrollWidth > buttonContainer.offsetWidth) {
    buttonContainer.classList.add('has-more');
    console.log('More options available - scroll indicator added');
  }
  
  // Add scroll event listener to update indicator
  buttonContainer.addEventListener('scroll', () => {
    const isAtEnd = buttonContainer.scrollLeft + buttonContainer.offsetWidth >= buttonContainer.scrollWidth - 1;
    if (isAtEnd) {
      buttonContainer.classList.remove('has-more');
    } else {
      buttonContainer.classList.add('has-more');
    }
  });
}

function clearOptionButtons() {
  const existingButtons = document.querySelector('.option-buttons');
  if (existingButtons) {
    existingButtons.remove();
  }
}

async function sendInitialPrompt(prompt) {
  showLoading();
  
  try {
    const response = await fetch(`${API_BASE}/chat`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        message: prompt,
        conversation_history: conversationHistory,
        temperature: 0.7,
        use_fine_tuned: true
      })
    });

    const data = await response.json();
    
    if (response.ok) {
      console.log('Initial AI Response data:', data);
      console.log('Initial AI Response text:', data.response);
      
      // Add initial prompt to display
      updateLatestPromptDisplay(prompt);
      currentPrompt = prompt.replace(/^["']|["']$/g, '');
      
      // Add user message to chat
      addMessage(prompt, 'user');
      
      if (data.is_question) {
        // Check for repetitive questions
        if (checkForRepetitiveQuestion(data.response)) {
          // Handle repetitive question
          await handleRepetitiveQuestion();
        } else {
          // AI asked a question with options
          addMessage(data.response, 'assistant');
          isWaitingForResponse = true;
          isInitialPrompt = false;
          skipButton.style.display = 'inline-block';
        }
      } else {
        // AI provided an updated prompt directly
        if (data.updated_prompt) {
          updateLatestPromptDisplay(data.updated_prompt);
          currentPrompt = data.updated_prompt.replace(/^["']|["']$/g, '');
          isUserEdit = false; // Reset flag for AI updates
        } else {
          addMessage(data.response, 'assistant');
        }
        isWaitingForResponse = false;
        skipButton.style.display = 'none';
      }
      
      conversationHistory = data.conversation_history;
    } else {
      addMessage('Sorry, I encountered an error. Please try again.', 'assistant');
    }
  } catch (error) {
    addMessage('Sorry, I encountered an error. Please try again.', 'assistant');
    console.error('Network error:', error);
  } finally {
    hideLoading();
  }
}

async function sendUserResponse(userResponse) {
  showLoading();
  
  try {
    const response = await fetch(`${API_BASE}/chat`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        message: userResponse,
        conversation_history: conversationHistory,
        temperature: 0.7,
        use_fine_tuned: true
      })
    });

    const data = await response.json();
    
    if (response.ok) {
      // Add user response to chat
      addMessage(userResponse, 'user');
      
      console.log('AI Response data:', data);
      console.log('AI Response text:', data.response);
      
      if (data.updated_prompt) {
        // AI provided an updated prompt
        clearOptionButtons();
        updateLatestPromptDisplay(data.updated_prompt);
        currentPrompt = data.updated_prompt.replace(/^["']|["']$/g, '');
        isUserEdit = false; // Reset flag for AI updates
        
        // Continue the conversation by sending the updated prompt back to AI
        setTimeout(() => {
          continueRefinement(data.updated_prompt);
        }, 1000);
      } else if (data.is_question) {
        // Check for repetitive questions
        if (checkForRepetitiveQuestion(data.response)) {
          // Handle repetitive question
          await handleRepetitiveQuestion();
        } else {
          // AI asked another question
          clearOptionButtons();
          addMessage(data.response, 'assistant');
          isWaitingForResponse = true;
          skipButton.style.display = 'inline-block';
        }
      } else {
        // Regular response
        clearOptionButtons();
        addMessage(data.response, 'assistant');
        isWaitingForResponse = false;
        skipButton.style.display = 'none';
      }
      
      conversationHistory = data.conversation_history;
    } else {
      addMessage('Sorry, I encountered an error. Please try again.', 'assistant');
    }
  } catch (error) {
    addMessage('Sorry, I encountered an error. Please try again.', 'assistant');
    console.error('Network error:', error);
  } finally {
    hideLoading();
  }
}

async function continueRefinement(updatedPrompt) {
  showLoading();
  
  console.log('Continue refinement called. Conversation history length:', conversationHistory.length);
  
  // Safety check: prevent infinite loops
  if (conversationHistory.length > 5) {
    addMessage('Maximum conversation length reached. Please start a new conversation.', 'assistant');
    console.log('Conversation limit reached. History length:', conversationHistory.length);
    hideLoading();
    return;
  }
  
  try {
    // Instead of sending the updated prompt directly, send a continuation message
    const continuationMessage = `Continue refining this prompt: ${updatedPrompt}`;
    
    const response = await fetch(`${API_BASE}/chat`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        message: continuationMessage,
        conversation_history: conversationHistory,
        temperature: 0.7,
        use_fine_tuned: true
      })
    });

    const data = await response.json();
    
    if (response.ok) {
      if (data.is_question) {
        // Check for repetitive questions
        if (checkForRepetitiveQuestion(data.response)) {
          // Handle repetitive question
          await handleRepetitiveQuestion();
        } else {
          // AI asked a new question based on updated prompt
          addMessage(data.response, 'assistant');
          isWaitingForResponse = true;
          isInitialPrompt = false;
          skipButton.style.display = 'inline-block';
          // Stop here and wait for user input
        }
      } else if (data.updated_prompt) {
        // Another updated prompt - show it and wait for user input
        updateLatestPromptDisplay(data.updated_prompt);
        currentPrompt = data.updated_prompt.replace(/^["']|["']$/g, '');
        
        // Show a message indicating the prompt was updated
        addMessage(`I've updated your prompt. You can continue refining it or let me know if you're satisfied.`, 'assistant');
        isWaitingForResponse = false;
        isInitialPrompt = true;
        skipButton.style.display = 'none';
      } else {
        // If AI didn't ask a question or provide updated prompt, 
        // stop and wait for user input
        addMessage(data.response, 'assistant');
        isWaitingForResponse = false;
        isInitialPrompt = true;
        skipButton.style.display = 'none';
      }
      
      conversationHistory = data.conversation_history;
    } else {
      addMessage('Sorry, I encountered an error. Please try again.', 'assistant');
    }
  } catch (error) {
    addMessage('Sorry, I encountered an error. Please try again.', 'assistant');
    console.error('Network error:', error);
  } finally {
    hideLoading();
  }
}

async function handleRepetitiveQuestion() {
  const antiRepetitionMessage = "Please ask a different question that hasn't been asked before in this session.";
  
  try {
    const response = await fetch(`${API_BASE}/chat`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        message: antiRepetitionMessage,
        conversation_history: conversationHistory,
        temperature: 0.7,
        use_fine_tuned: true
      })
    });

    const data = await response.json();
    
    if (response.ok) {
      if (data.is_question && !checkForRepetitiveQuestion(data.response)) {
        addMessage(data.response, 'assistant');
        isWaitingForResponse = true;
        skipButton.style.display = 'inline-block';
      } else {
        addMessage("I've asked all the relevant questions. Please continue refining your prompt or let me know if you need any specific changes.", 'assistant');
        isWaitingForResponse = false;
        skipButton.style.display = 'none';
      }
      
      conversationHistory = data.conversation_history;
    } else {
      addMessage("Please continue refining your prompt or let me know if you need any specific changes.", 'assistant');
      isWaitingForResponse = false;
      skipButton.style.display = 'none';
    }
  } catch (error) {
    console.error('Error handling repetitive question:', error);
    addMessage("Please continue refining your prompt or let me know if you need any specific changes.", 'assistant');
    isWaitingForResponse = false;
    skipButton.style.display = 'none';
  }
}

async function skipQuestion() {
  if (!isWaitingForResponse) {
    return;
  }
  
  skipButton.disabled = true;
  addMessage("(Skipped this question)", 'user');
  showLoading();
  
  const skipMessage = "Please skip this question and continue with the next step or ask a different question.";
  
  try {
    const response = await fetch(`${API_BASE}/chat`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        message: skipMessage,
        conversation_history: conversationHistory,
        temperature: 0.7,
        use_fine_tuned: true
      })
    });

    const data = await response.json();
    
    if (response.ok) {
      clearOptionButtons();
      
      if (data.is_question) {
        if (checkForRepetitiveQuestion(data.response)) {
          await handleRepetitiveQuestion();
        } else {
          addMessage(data.response, 'assistant');
          isWaitingForResponse = true;
          skipButton.style.display = 'inline-block';
        }
      } else {
        addMessage(data.response, 'assistant');
        isWaitingForResponse = false;
        skipButton.style.display = 'none';
      }
      
      conversationHistory = data.conversation_history;
    } else {
      addMessage('Sorry, I encountered an error while skipping the question. Please try again.', 'assistant');
    }
  } catch (error) {
    addMessage('Sorry, I encountered an error while skipping the question. Please try again.', 'assistant');
    console.error('Network error:', error);
  } finally {
    hideLoading();
    skipButton.disabled = false;
  }
}

function resetChat() {
  conversationHistory = [];
  currentPrompt = '';
  isWaitingForResponse = false;
  isInitialPrompt = true;
  isUserEdit = false;
  askedQuestions.clear();
  
  chatMessages.innerHTML = `
    <div class="message assistant">
      <div class="message-avatar">AI</div>
      <div class="message-content">
        Hello! I'm your prompt refinement assistant. Type your prompt below and I'll help you refine it for better layout generation.
      </div>
    </div>
  `;
  
  clearOptionButtons();
  chatInput.value = '';
  chatInput.style.height = 'auto';
  skipButton.style.display = 'none';
  latestPromptDisplay.style.display = 'none';
}

// Event listeners
chatForm.addEventListener('submit', (e) => {
  e.preventDefault();
  const message = chatInput.value.trim();
  
  if (message) {
    if (isInitialPrompt) {
      // This is the initial prompt
      sendInitialPrompt(message);
    } else {
      // This is a response to AI's question
      sendUserResponse(message);
    }
    chatInput.value = '';
    chatInput.style.height = 'auto';
  }
});

chatInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    chatForm.dispatchEvent(new Event('submit'));
  }
});

// Clear option buttons when user starts typing
chatInput.addEventListener('input', () => {
  const optionButtons = document.querySelectorAll('.option-buttons');
  optionButtons.forEach(container => {
    const buttons = container.querySelectorAll('.option-button');
    buttons.forEach(btn => btn.classList.add('disabled'));
  });
});

// Original layout generation functionality
let firstPrompt = '';

window.onload = () => {
  loading.style.display = 'none';
  sendBtn.disabled = false;
};

// Add click handlers for option boxes
document.querySelectorAll('.option-box').forEach(box => {
  box.addEventListener('click', () => {
    box.classList.toggle('selected');
  });
});

document.getElementById('send').onclick = () => {
  const selectedOptions = Array.from(document.querySelectorAll('.option-box.selected')).map(box => box.dataset.value);
  if (selectedOptions.length === 0) {
    alert('Please select at least one option.');
    console.warn('[UI] Send clicked, but no options selected!');
    return;
  }
  parent.postMessage({ pluginMessage: { type: 'send', selectedOptions } }, '*');
  loading.style.display = 'block';
  sendBtn.disabled = true;
};

window.onmessage = (event) => {
  const msg = event.data.pluginMessage;
  if (msg?.type === 'loading') {
    loading.style.display = msg.loading ? 'block' : 'none';
    sendBtn.disabled = msg.loading;
  }
};
</script>
</body>
</html>
